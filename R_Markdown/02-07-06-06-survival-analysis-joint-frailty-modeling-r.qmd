::: {layout-ncol="2"}
[![](Image/RENEW_logo.png){fig-align="left"}](https://www.buffalo.edu/renew.html)

[![](Image/github_R.png){fig-align="right" width="200"}](https://github.com/zia207/Survival_Analysis_R/tree/main/Notebook/02_07_06_06_survival_analysis_joint_frailty_modeling_r.ipynb)
:::

# 6.6 Joint Frailty Models For Recurrent and Terminal Events {.unnumbered}

Joint frailty models extend standard frailty models by simultaneously analyzing two or more related survival processes, typically recurrent events (e.g., repeated hospitalizations or tumor recurrences) and a terminal event (e.g., death), which censors the recurrent process. These models account for the dependence between the processes through shared or correlated frailty terms, addressing informative censoring where the terminal event is influenced by the same unobserved heterogeneity as the recurrent events. Without joint modeling, separate analyses may lead to biased estimates because the terminal event is not independent of the recurrent process.

In many studies, recurrent events are observed until a terminal event occurs, and these processes are correlated due to shared unobserved factors (e.g., frailty-prone individuals may have more recurrences and die earlier). Joint models capture this by linking the hazards via frailties, improving efficiency and reducing bias from ignoring dependence.

- **Frailty Role**: Frailties are random effects representing unobserved heterogeneity. In joint models, a shared frailty (e.g., $u_i$ for individual $i$ multiplies the baseline hazards of both processes, inducing positive correlation. Correlated frailties allow for more flexible dependence, including negative correlations.

- **Effects**:

  - **Selection and Dependence**: Frailer individuals experience events faster and may exit via the terminal event, leading to a healthier survivor population over time.
  
  - **Informative Censoring**: Models explicitly handle cases where censoring (terminal event) depends on frailty, unlike standard models assuming independent censoring.
  
  - **Association Parameter**: Often includes a parameter (e.g., $\alpha$)) scaling the frailty's impact on the terminal hazard, quantifying the strength of association between processes.

## Joint Frailty model

Fit a joint either with gamma or log-normal frailty model for recurrent and terminal events using a penalized likelihood estimation on the hazard function or a parametric estimation. Right-censored data and strata (up to 6 levels) for the recurrent event part are allowed. Left-truncated data is not possible. Joint frailty models allow studying, jointly, survival processes of recurrent and terminal events, by considering the terminal event as an informative censoring.

There is two kinds of joint frailty models that can be fitted with `frailtyPenal`:

- The first one (Rondeau et al. 2007) includes a common frailty term to the individuals $\omega_i$ for the two rates which will take into account the heterogeneity in the data, associated with unobserved covariates. The frailty term acts differently for the two rates ($\omega_i$ for the recurrent rate and $\omega_i^{\text{exp}(\text{alpha})}$ for the death rate). The covariates could be different for the recurrent rate and death rate.

For the $j^{th}$ recurrence ($j$=1,...,N) and the $i^{th}$ subject ($i$=1,...,G), the joint gamma frailty model for recurrent event hazard function $r_{ij}(t)$ and death rate $\lambda_i$ is:

$$
\begin{cases}
r_{ij}(t|\omega_i) = \omega_i r_0(t) \exp(\beta_1' Z_{1i}(t)) & \text{(Recurrent)} \\
\lambda_i(t|\omega_i) = \omega_i^\alpha \lambda_0(t) \exp(\beta_2' Z_{2i}(t)) & \text{(Death)}
\end{cases}
$$

where $r_0(t)$ (resp. $\lambda_0(t)$) is the recurrent (resp. terminal) event baseline hazard function, $\beta_1$ (resp. $\beta_2$) the regression coefficient vector. $Z_{1i}(t)$ the covariate vector. The random effects of frailties $\omega_i \sim \Gamma(1/\theta, 1/\theta)$ and are iid.

The joint log-normal frailty model will be:

$$
\begin{cases}
r_{ij}(t|\eta_i) = r_0(t) \exp(\eta_i + \beta_1' Z_{1i}(t)) & \text{(Recurrent)} \\
\lambda_i(t|\eta_i) = \lambda_0(t) \exp(\alpha\eta_i + \beta_2' Z_{2i}(t)) & \text{(Death)}
\end{cases}
$$

$$ \eta_i \sim N(0, \sigma^2) $$

- The second one (Rondeau et al. 2011) is quite similar but the frailty term is common to the individuals from a same group. This model is useful for the joint modelling two clustered survival outcomes. This joint models have been developed for clustered semi-competing events. The follow-up of each of the two competing outcomes stops when the event occurs. In this case, $j$ is for the subject and $i$ for the cluster.

$$
\begin{cases}
r_{ij}(t|u_i) = u_i r_0(t) \exp(\beta_1' Z_{1ij}(t)) & \text{(Time to event)} \\
\lambda_{ij}(t|u_i) = u_i^\alpha \lambda_0(t) \exp(\beta_2' Z_{2ij}(t)) & \text{(Death)}
\end{cases}
$$

It should be noted that in these models it is not recommended to include $\alpha$ parameter as there is not enough information to estimate it and thus there might be convergence problems.


In case of a log-normal distribution of the frailties, we will have:

$$
\begin{cases}
r_{ij}(t|v_i) = r_0(t) \exp(v_i + \beta_1' Z_{1ij}(t)) & \text{(Time to event)} \\
\lambda_{ij}(t|v_i) = \lambda_0(t) \exp(\alpha v_i + \beta_2' Z_{2ij}(t)) & \text{(Death)}
\end{cases}
$$

$$ v_i \sim N(0, \sigma^2) $$

This joint frailty model can also be applied to clustered recurrent events and a terminal event (example on "readmission" data below).

From now on, you can also consider time-varying effects covariates in your model, see `timedep` function for more details.

There is a possibility to use a weighted penalized maximum likelihood approach for nested case-control design, in which risk set sampling is performed based on a single outcome (Jazic et al., *Submitted*).


## Joint Nested Frailty Model

Fit a joint model for recurrent and terminal events using a penalized likelihood on the hazard functions or a parametric estimation. Right-censored data are allowed but left-truncated data and stratified analysis are not allowed.

Joint nested frailty models allow studying, jointly, survival processes of recurrent and terminal events for hierarchically clustered data, by considering the terminal event as an informative censoring and by including two iid gamma random effects.

The joint nested frailty model includes two shared frailty terms, one for the subgroup ($u_k$) and one for the group ($w_l$) into the hazard functions. This random effects account the heterogeneity in the data, associated with unobserved covariates. The frailty terms act differently for the two rates ($u_k w_l^{\text{exp}(\text{alpha})}$ for the recurrent rate and $u_k w_l^{\text{exp}(\text{alpha})}$ for the terminal event rate). The covariates could be different for the recurrent rate and death rate.

For the $j^{th}$ recurrence ($j=1, ..., n_k$) of the $i^{th}$ individual ($i=1, ..., m_l$) of the $k^{th}$ group ($k=1, ..., n$), the joint nested gamma frailty model for recurrent event hazard function $r_{lij}(t)$ and for terminal event hazard function $\lambda_{li}$ is:

$$
\begin{cases}
r_{lij}(t|w_l, u_k, X_{lij}) = r_0(t) u_k w_l^\beta \exp(\beta' X_{lij}) & \text{(Recurrent)} \\
\lambda_{li}(t|w_l, u_k, X_{li}) = \lambda_0(t) u_k w_l^\gamma \exp(\gamma' X_{li}) & \text{(Death)}
\end{cases}
$$

where $r_0(\text{resp. } \lambda_0)$ is the recurrent (resp. terminal) event baseline hazard function, $\beta$ (resp. $\gamma$) the regression coefficient vector. $X_{lij}(t)$ the covariates vector. The random effects are $w_l \sim \Gamma(1/\eta, 1/\eta)$ and $u_k \sim \Gamma(1/\theta, 1/\theta)$.


## Joint Frailty Models  in R 

{frailtypack} is an R package for fitting frailty models (shared, nested, joint, additive) to correlated survival data** with **recurrent** and **terminal events**. It uses penalized likelihood with splines  or parametric hazards, supports time-varying covariates, and enables prediction.  


### Install Required R Packages

Following R packages are required to run this notebook. If any of these packages are not installed, you can install them using the code below:

```{r}
packages <-c(
		 'tidyverse',
	   'JMbayes2',
		 'frailtypack'
		 
		 )

```

```{r
#| warning: false
#| error: false

# Install missing packages
new_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)

#devtools::install_github("ItziarI/WeDiBaDis")
```

### Verify Installation

```{r}
# Verify installation
cat("Installed packages:\n")
print(sapply(packages, requireNamespace, quietly = TRUE))
```

### Load Packages

```{r}
#| warning: false
#| error: false
# Load packages with suppressed messages
invisible(lapply(packages, function(pkg) {
  suppressPackageStartupMessages(library(pkg, character.only = TRUE))
}))
```

```{r}
# Check loaded packages
cat("Successfully loaded packages:\n")
print(search()[grepl("package:", search())])
```

### Data

This tutorial uses the `readmission` dataset from the `frailtypack` package, which includes 403 patients post-colorectal cancer surgery with recurrent re-hospitalizations (up to 4) and overall survival (terminal event). Columns: `id` (patient ID), `t.start`/`t.stop` (interval times), `event` (recurrence indicator), `enum` (event number), `time` (gap time to recurrence), `dukes` (tumor stage), `charlson` (comorbidity), `sex` (1=male), `chemo` (chemotherapy), `death` (terminal indicator).


```{R}
data(readmission)
# Structure
str(readmission)
# Summary
summary(readmission)
```


```{R}
# Number of patients, recurrences, deaths
length(unique(readmission$id))  # 403 patients
sum(readmission$event)  # 467 recurrences
sum(readmission$death)  # Deaths (terminal)
```



### Fitting Joint Frailty Models

Joint frailty models simultaneously analyze **recurrent events** (e.g., hospitalizations) and a **terminal event** (e.g., death), accounting for **dependence** via shared or nested **random effects (frailties)**. Using the `readmission` dataset, this tutorial demonstrates:

- **General Joint Model** (two frailties)  
- **Standard Joint Model** (with/without α, log-normal frailty)  
- **Joint Nested Model** (hierarchical clustering)  

We cover **gap time** and **calendar time** formulations, plus **model diagnostics** (AIC, residuals, prediction).  


### General Joint Frailty Model

We first fit a **General Joint Frailty Model** with gamma frailty for both recurrent and terminal events, using **gap time** (PWP-type) and Calendar Time (Andersen-Gill-type) data. These models include a shared frailty term affecting both processes, capturing unobserved heterogeneity.

#### Gap Time (PWP-type)

Gap time models reset the time scale after each event, focusing on intervals between recurrences. This is suitable when the risk of recurrence depends on the number of prior events.

```{r}
# General Joint (Gap Time)
fit_gen_gap <- frailtyPenal(
  # Recurrent part – MUST include cluster()
  Surv(time,event)~cluster(id)+sex+dukes+charlson+terminal(death),
  # Terminal part
  formula.terminalEvent=~sex+dukes+charlson,
  data=readmission,
  n.knots=14,
  kappa=c(9.55e+9,1.41e+12),
  recurrentAG=FALSE)
summary(fit_gen_gap)
```

`

#### Calendar Time (Andersen-Gill-type)

Calendar time models use the original time scale, allowing risk to accumulate over the entire follow-up period. This is appropriate when the risk of recurrence depends on absolute time since study entry.


```{r}
fit_gen_cal<-frailtyPenal(
  # Recurrent part – MUST include cluster()
  Surv(t.start,t.stop,event)~cluster(id)+sex+dukes+charlson+terminal(death),
  # Terminal part
  formula.terminalEvent=~sex+dukes+charlson,
  data=readmission,
  n.knots=10,
  kappa=c(9.55e9,1.41e12),
  recurrentAG=TRUE)
summary(fit_gen_cal)
```


### Standard Joint Frailty Model (No $\alpha$, Log-Normal Frailty)

We next fit a **Standard Joint Frailty Model** with options for including/excluding the association parameter $\alpha$ and using a log-normal frailty distribution. This model captures dependence between recurrent and terminal events via a shared frailty term.


```{r}
fit_std_gap_noalpha_logn <- frailtyPenal(
  Surv(time, event) ~ cluster(id)+sex+dukes+charlson+terminal(death),
  formula.terminalEvent = ~ sex+dukes+charlson,
  data = readmission,
  recurrentAG = FALSE,
  RandDist = "LogN",
  Alpha = "None",        # No alpha
  n.knots = 10,
  kappa = c(1e9, 1e10)
)
summary(fit_std_gap_noalpha_logn)
```

#### Calendar Time (Andersen-Gill-type)

```{r}
fit_std_cal_logn <- frailtyPenal(
  Surv(t.start, t.stop, event) ~ cluster(id)+sex+dukes+charlson+terminal(death),
  formula.terminalEvent = ~ sex+dukes+charlson,
  data = readmission,
  recurrentAG = TRUE,
  RandDist = "LogN",
  n.knots = 8,
  kappa = c(1e8, 1e9)
)
summary(fit_std_cal_logn)
```



### Joint Nested Frailty Model

```{r}
# Joint Nested (Gap Time)
readmission$group <- (readmission$id - 1) %/% 10 + 1
fit_nest_gap <- frailtyPenal(
  Surv(time, event) ~ subcluster(id) + cluster(group) + dukes + trt,
  formula.terminalEvent = ~ dukes + trt,
  data = readmission,
  recurrentAG = FALSE,
  n.knots = 8,
  kappa = c(1e9, 1e10),
  initialize = TRUE
)
```

---

## **2. Model Diagnostics**

### **A. Model Fit Comparison**

```r
# AIC & BIC
fit_stats <- data.frame(
  Model = c("General Joint", "Standard (No alpha, LogN)", "Joint Nested"),
  AIC = c(AIC(fit_gen_gap), AIC(fit_std_noalpha_logn), AIC(fit_nest_gap)),
  BIC = c(BIC(fit_gen_gap), BIC(fit_std_noalpha_logn), BIC(fit_nest_gap)),
  LogLik = c(fit_gen_gap$loglikPenal, fit_std_noalpha_logn$loglikPenal, fit_nest_gap$loglikPenal)
)
print(fit_stats)
```

> **Lower AIC/BIC** → better fit.

---

### **B. Frailty Variance Tests**

```r
# Test theta = 0 (no frailty)
fit_null <- frailtyPenal(
  Surv(time, event) ~ dukes + trt + sex,
  formula.terminalEvent = ~ dukes + trt,
  data = readmission,
  recurrentAG = FALSE
)

anova(fit_gen_gap, fit_null)  # LRT for frailty
```

> **p < 0.05** → frailty is significant.

---

### **C. Residuals Analysis**

```r
# Martingale residuals (recurrent & terminal)
mart_rec <- residuals(fit_gen_gap, type = "martingale")
mart_term <- residuals(fit_gen_gap, type = "martingaledeath")

# Plot: Recurrent
plot(mart_rec, ylab = "Martingale Residuals (Recurrent)", pch = 16, col = "blue")
abline(h = 0, lty = 2)

# Plot: Terminal
plot(mart_term, ylab = "Martingale Residuals (Death)", pch = 16, col = "red")
abline(h = 0, lty = 2)
```

> **Random scatter around 0** → good fit.  
> **Patterns** → model misspecification.

---

### **D. Frailty Distribution**

```r
# Empirical Bayes frailty estimates
frailty_eb <- fit_gen_gap$frailty.pred

# Histogram
hist(frailty_eb, main = "Posterior Frailty Distribution", xlab = "Frailty (log scale)", 
     breaks = 30, col = "lightblue", border = "black")
abline(v = mean(frailty_eb), col = "red", lwd = 2, lty = 2)
```

> **Right-skewed** → gamma frailty appropriate.

---

### **E. Baseline Hazard & Survival Functions**

```r
# Extract and plot baseline survival (recurrent)
plot(fit_gen_gap, type.plot = "Survival", conf.bands = TRUE, 
     main = "Baseline Survival (Recurrent Events)", col = "blue")

# Terminal
plot(fit_gen_gap, type.plot = "Survival", event = "terminal", 
     main = "Baseline Survival (Death)", col = "red")
```

> **Smooth curves + narrow CIs** → good spline fit.

---

### **F. Proportional Hazards Check (Schoenfeld-like)**

```r
# For recurrent model (approximate)
library(survival)
cox_rec <- coxph(Surv(time, event) ~ dukes + trt + sex + cluster(id), data = readmission)
plot(cox.zph(cox_rec))  # Not perfect, but gives idea
```

> Use with caution — frailty violates PH assumption.

---

### **G. Prediction Accuracy (Dynamic AUC)**

```r
# Predict 1-year risk for all patients
pred1y <- predict(fit_gen_gap, t = 365)

# Observed outcomes at t = 365
obs_rec <- ifelse(readmission$time <= 365 & readmission$event == 1, 1, 0)
obs_death <- ifelse(readmission$time <= 365 & readmission$death == 1, 1, 0)

# AUC (requires timeROC or pec)
# install.packages("timeROC")
library(timeROC)
ROC_rec <- timeROC(T = readmission$time, delta = readmission$event,
                   marker = pred1y$pred.rec, cause = 1, times = 365)
ROC_rec$AUC
```

> **AUC > 0.7** → good discrimination.

---

### **H. Convergence & Numerical Stability**

```r
# Check convergence
fit_gen_gap$n.iter
fit_gen_gap$istop  # 1 = converged

# Kappa sensitivity
fit_k1 <- update(fit_gen_gap, kappa = c(1e7, 1e10))
fit_k2 <- update(fit_gen_gap, kappa = c(1e9, 1e12))
c(AIC(fit_k1), AIC(fit_gen_gap), AIC(fit_k2))
```

> **Stable AIC** → robust smoothing.

---

## **Summary: Diagnostic Checklist**

| Diagnostic | Code | Good Sign |
|----------|------|----------|
| **AIC/BIC** | `AIC()`, `BIC()` | Lowest |
| **Frailty test** | `anova()` | p < 0.05 |
| **Residuals** | `residuals()` | Random around 0 |
| **Frailty dist.** | `hist(frailty.pred)` | Right-skewed |
| **Survival plot** | `plot(..., type="Survival")` | Smooth + narrow CI |
| **Prediction** | `predict() + timeROC` | AUC > 0.7 |
| **Convergence** | `$n.iter`, `$istop` | `istop == 1` |

---

**You're now fully equipped** to **fit**, **diagnose**, and **validate** joint frailty models in R!


## Summary and Conclusion

Joint frailty models provide a powerful framework for analyzing correlated survival processes, such as recurrent events censored by a terminal event, by incorporating shared or correlated random effects to model dependence and heterogeneity. They outperform separate or standard frailty models by addressing informative censoring, yielding unbiased estimates, and quantifying process associations via parameters like \( \alpha \). In the readmission example, the model revealed that factors like tumor stage and comorbidity increase both re-hospitalization and mortality risks, with significant positive linkage between processes.

Joint frailty models are crucial in survival analysis for realistic modeling of complex data structures, enhancing interpretability in clinical and epidemiological contexts where events are interdependent. They mitigate biases from ignored correlations but require careful assumption checks (e.g., frailty distribution) and computational resources. Compared to multi-state models, they emphasize unobserved heterogeneity over state transitions, making them ideal for frailty-driven dependence. Future extensions, like time-varying frailties, offer even greater flexibility.

##  Resources 

- **Tutorial Paper: A Tutorial on Frailty Models** by Theodor A. Balan and Hein Putter (2020). Covers joint frailty extensions for recurrent and terminal events.
- **R Package Documentation: frailtypack** (CRAN). Comprehensive for fitting joint frailty models; see vignette for examples.
- **Blog Post: Joint Frailty Models for Recurrent and Terminal Events** by Red Door Analytics. Practical guide with formulations and interpretation.
- **Paper: An Introduction to Frailty Models for Multivariate Survival Data** (2018). Discusses joint models for recurrent and terminal events.
- **Book/Paper: Frailty Models in Survival Analysis** by Andreas Wienke (2010). In-depth on joint and correlated frailties.

*Based on the official `frailtypack::frailtyPenal` documentation*  
[https://search.r-project.org/CRAN/refmans/frailtypack/html/frailtyPenal.html](https://search.r-project.org/CRAN/refmans/frailtypack/html/frailtyPenal.html)

1. **Rondeau, V., et al. (2007).**  
   *Joint frailty models for recurring events and death using maximum penalized likelihood estimation.*  
   *Biometrics*, 63(4), 1057–1066.

2. **Rondeau, V., et al. (2011).**  
   *Joint modeling of two clustered survival outcomes.*  
   *Lifetime Data Analysis*.
